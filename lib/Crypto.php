<?php

namespace Stateless;

defined("NONCE_TIME_LENGTH") or define("NONCE_TIME_LENGTH", 10);

/**
 * @brief Create and verify nonces and other cryptography strings
 */
class Crypto {
    /**
     * @brief Hash a string
     * @param string $str The string to hash
     */
    public static function hash($str) {
        return password_hash($str, PASSWORD_BCRYPT);
    }

    /**
     * @brief Verify a clear-text string against a hash
     * @param string $str The clear-text string
     * @param string $hash The hash to verify
     * @return boolean Returns if $str matches $hash
     */
    public static function verifyHash($str, $hash) {
        return password_verify($str, $hash);
    }

    /**
     * @brief Appends $salt to $str
     * @param string $str The string to salt
     * @param string $salt The salt to append
     * @return boolean Returns the salted string
     */
    public static function salt($str, $salt) {
        return $str . $salt;
    }

    /**
     * @brief Returns pepper generated by $uuid
     * @param mixed $uuid The user Id to generate the pepper from
     * @param mixed $pepperLength Length of the pepper to create
     * @return string Returns the generated pepper
     */
    public static function getPepper($uuid, $pepperLength) {
        $uuid = strval($uuid);
        $hash = sha1($uuid);
        $hash = substr($hash, strlen($hash) - $pepperLength);

        return substr($hash, 0, $pepperLength);
    }

    /**
     * @brief Prepends pepper to $str
     * @param string $str The string to pepper
     * @param mixed $uuid User Id to derive the pepper from
     * @param mixed $pepperLength Length of the pepper to create
     * @return string Returns the peppered string
     */
    public static function pepper($str, $uuid, $pepperLength) {
        return Crypto::getPepper($uuid, $pepperLength) . $str;
    }

    /**
     * @brief Joins salt and pepper with the string
     * @param string $str The string to salt and pepper
     * @param mixed $uuid The user Id to derive the pepper from
     * @param string $salt String to use as a salt
     * @param integer $pepperLength Length of the pepper to generate
     * @return string Returns the string with salt and pepper
     */
    public static function spice($str, $uuid, $salt, $pepperLength) {
        return Crypto::getPepper($uuid, $pepperLength) . Crypto::salt($str, $salt);
    }

    /**
     * @brief Check if $str contains $salt
     * @param string $str The string to check
     * @param string $salt The salt to check for
     * @return boolean Returns if the salt is at the end
     */
    public static function checkSalt($str, $salt) {
        $strlen = strlen($str);
        $saltLen = strlen($salt);

        return (
            substr_compare($str, $salt, $strlen-$saltLen, $saltLen) === 0
        );
    }

    /**
     * @brief Check for pepper at the beginning of $str
     * @param string $str The string to check
     * @param integer $uuid The user Id to check for
     * @param integer $pepperLength The length of the pepper
     * @return boolean Returns if the pepper is at the beginning of $str
     */
    public static function checkPepper($str, $uuid, $pepperLength) {
        $pepper = Crypto::pepper("", $uuid, $pepperLength);

        return (
            substr_compare(substr($str, 0, $pepperLength), $pepper, 0) === 0
        );
    }
    
    /**
     * @brief Check $str for spice (salt and pepper)
     * @param string $str The string to check
     * @param integer $uuid The user Id to validate
     * @param string $salt The salt to check for
     * @param integer $pepperLength The length of the pepper
     * @return boolean Returns if the salt and pepper are valid
     */
    public static function checkSpice($str, $uuid, $salt, $pepperLength) {
        return (
            Crypto::checkSalt($str, $salt) &&
            Crypto::checkPepper($str, $uuid, $pepperLength)
        );
    }

    /**
     * @brief Remove $salt from $str, if it exists
     * @param string $str The string to unsalt
     * @param string $salt The salt to remove from the string
     * @return string Returns the unsalted string
     */
    public static function unsalt($str, $salt) {
        return substr($str, 0, strlen($str) - strlen($salt));
    }

    /**
     * @brief Remove pepper from $str, if it exists
     * @param string $str The string to unpepper
     * @param integer $uuid The user Id to unpepper
     * @param integer $pepperLength The length of the pepper
     * @return string Returns the unpeppered string
     */
    public static function unpepper($str, $uuid, $pepperLength) {
        // Check if pepper exists
        if (Crypto::checkPepper($str, $uuid, $pepperLength)) {

            // Return the unpeppered string
            return substr($str, $pepperLength);
        }
        else {

            // Return the string
            return $str;
        }
    }

    /**
     * @brief Remove $salt and pepper from $str, if it exists
     * @param string $str The string to unspice
     * @param integer $uuid The user Id to unpepper
     * @param string $salt The salt to remove
     * @param integer $pepperLength The length of the pepper to remove
     * @return string Returns the unspiced string
     */
    public static function unspice($str, $uuid, $salt, $pepperLength) {
        return Crypto::unsalt(
            Crypto::unpepper($str, $uuid, $pepperLength),
            $salt
        );
    }

    /**
     * @brief Get a new encoded OpenSSL key
     * @param integer $len Length of the key
     * @return string Returns the OpenSSL key
     */
    public static function getKey($len = 64) {
        return base64_encode(openssl_random_pseudo_bytes($len));
    }

    /**
     * @brief Get an OpenSSL initialization vector
     * @param string $method Cipher method.  Default is "aes-256-gcm"
     * @return mixed Returns the iv, or false on failure
     */
    public static function getIv($method = "aes-256-gcm") {
        if (in_array($method, openssl_get_cipher_methods())) {
            $ivlen = openssl_cipher_iv_length($method);
            return openssl_random_pseudo_bytes($ivlen);
        }
        else {
            return false;
        }
    }

    /**
     * @brief Encrypt $str
     * @param string $str String to encrypt
     * @param string $key Cipher key generated by Crypto::getKey()
     * @param string $iv Initialization vector generated by Crypto::getIv()
     * @param reference $tag Reference to $tag
     * @param string $method Cipher method.  Default is "aes-256-gcm"
     * @param mixed $options OpenSSL options
     * @return mixed Returns the encrypted string, or false on failure
     */
    public static function encrypt(
        $str,
        $key,
        $iv,
        &$tag,
        $method = "aes-256-gcm",
        $options = 0
    ) {
        if (in_array($method, openssl_get_cipher_methods())) {
            return openssl_encrypt(
                $str,
                $method,
                $key,
                $options,
                $iv,
                $tag
            );
        }
        else {
            return false;
        }
    }

    /**
     * @brief Decrypt $str
     * @param string $str Encrypted string to decrypt
     * @param string $key Cipher key generated by Crypto::getKey()
     * @param string $iv Initialization vector generated by Crypto::getIv()
     * @param reference $tag Reference to $tag
     * @param string $method Cipher method.  Default is "aes-256-gcm"
     * @param mixed $options OpenSSL options
     * @return mixed Returns the decrypted string or false on failure
     */
    public static function decrypt(
        $str,
        $key,
        $iv,
        &$tag,
        $method = "aes-256-gcm",
        $options = 0
    ) {
        if (in_array($method, openssl_get_cipher_methods())) {
            return openssl_decrypt(
                $str,
                $method,
                $key,
                $options,
                $iv,
                $tag
            );
        }
        else {
            return false;
        }
    }

    /**
     * @brief Returns a timestamp to be used with a nonce
     * @return integer Returns the timestamp
     */
    public static function nonceTime() {
        //$dt = new DateTime();
        //return $dt->getTimestamp();

        return time();
    }

    /**
     * @brief Creates a hashed nonce string
     * @param string $action The action being performed
     * @param integer $uuid The user Id to include in the nonce
     * @param integer $obid The object Id currently being edited
     * @param integer $ttl The amount of time from now until the nonce expires
     * @param string $salt The string the nonce was salted with
     * @param integer $pepperLength The length of the pepper
     * @param string $cipherKey Cipher key generated by Crypto::getKey()
     * @param string $cipherIv Initialization vector generated by Crypto::getIv()
     * @param reference $cipherTag Reference to $tag
     * @param string $cipherMethod Cipher method.  Default is "aes-256-gcm"
     * @param mixed $cipherOptions OpenSSL options
     * @return string Returns the hashed nonce
     */
    public static function nonce(
        $action,
        $uuid,
        $obid,
        $ttl,
        $salt,
        $pepperLength,
        $cipherKey,
        &$cipherIv,
        &$cipherTag,
        $cipherMethod = "aes-256-gcm",
        $cipherOptions = 0
    ) {
        $time = Crypto::nonceTime() + $ttl;
        $hash = Crypto::hash($action . $uuid . $obid);
        $spice = Crypto::spice(
            $time . $hash,
            $uuid,
            $salt,
            $pepperLength
        );
        $cipher = Crypto::encrypt(
            $spice,
            $cipherKey,
            $cipherIv,
            $cipherTag,
            $cipherMethod,
            $cipherOptions
        );

        return $cipher;
    }

    /**
     * @brief Validates a nonce string
     * @param string $nonce The nonce to check
     * @param string $action The action being performed
     * @param integer $uuid The user Id to include in the nonce
     * @param integer $obid The object Id currently being edited
     * @param integer $ttl Time to live, in seconds
     * @param string $salt The string the nonce was salted with
     * @param integer $pepperLength The length of the pepper
     * @param string $cipherKey Cipher key generated by Crypto::getKey()
     * @param string $cipherIv Initialization vector generated by Crypto::getIv()
     * @param reference $cipherTag Reference to $tag
     * @param string $cipherMethod Cipher method.  Default is "aes-256-gcm"
     * @param mixed $cipherOptions OpenSSL options
     * @return boolean Returns if the nonce is valid
     */
    public static function validateNonce(
        $nonce,
        $action,
        $uuid,
        $obid,
        $ttl,
        $salt,
        $pepperLength,
        $cipherKey,
        &$cipherIv,
        &$cipherTag,
        $cipherMethod = "aes-256-gcm",
        $cipherOptions = 0
    ) {
        // Decrypt
        $nonce = Crypto::decrypt(
            $nonce,
            $cipherKey,
            $cipherIv,
            $cipherTag,
            $cipherMethod,
            $cipherOptions
        );
        // Check for spice & remove
        if (!Crypto::checkSpice($nonce, $uuid, $salt, $pepperLength)) {
            return false;
        }

        // Unspice the nonce
        $nonce = Crypto::unspice($nonce, $uuid, $salt, $pepperLength);

        // Get the current time
        $time = Crypto::nonceTime();
        $timeLen = strlen($time);

        // Split timestamp from payload
        $expires = substr($nonce, 0, $timeLen);
        $nonce = substr($nonce, $timeLen);

        // Check timestamp
        if ($time > $expires) {
            return false;
        }

        // Check the action, uuid, & object id
        $payload = $action . $uuid . $obid;

        if (!password_verify($payload, $nonce)) {
            return false;
        }
        
        // All checks OK, return true
        return true;
    }

    /**
     * @brief Generates a hidden nonce field
     * @param string $key The key for this field in the form
     * @param string $nonce The nonce for the value of this form
     * @return string Returns the html markup of the hidden field
     */
    public static function getNonceField($key, $nonce) {
        return sprintf(
            "<input type=\"hidden\" name=\"%s\" value=\"%s\">",
            $key,
            $nonce
        );
    }
}